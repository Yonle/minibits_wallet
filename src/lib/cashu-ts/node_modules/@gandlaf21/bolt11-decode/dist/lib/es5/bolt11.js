"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hrpToMillisat = exports.decode = void 0;
var bech32 = require("bech32");
var buffer_1 = require("buffer");
var bn_js_1 = require("bn.js");
// defaults for encode; default timestamp is current time at call
var DEFAULTNETWORK = {
    // default network is bitcoin
    bech32: 'bc',
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    validWitnessVersions: [0]
};
var TESTNETWORK = {
    bech32: 'tb',
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    validWitnessVersions: [0]
};
var REGTESTNETWORK = {
    bech32: 'bcrt',
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    validWitnessVersions: [0]
};
var SIMNETWORK = {
    bech32: 'sb',
    pubKeyHash: 0x3f,
    scriptHash: 0x7b,
    validWitnessVersions: [0]
};
var FEATUREBIT_ORDER = [
    'option_data_loss_protect',
    'initial_routing_sync',
    'option_upfront_shutdown_script',
    'gossip_queries',
    'var_onion_optin',
    'gossip_queries_ex',
    'option_static_remotekey',
    'payment_secret',
    'basic_mpp',
    'option_support_large_channel'
];
var DIVISORS = {
    m: new bn_js_1.BN(1e3, 10),
    u: new bn_js_1.BN(1e6, 10),
    n: new bn_js_1.BN(1e9, 10),
    p: new bn_js_1.BN(1e12, 10)
};
var MAX_MILLISATS = new bn_js_1.BN('2100000000000000000', 10);
var MILLISATS_PER_BTC = new bn_js_1.BN(1e11, 10);
var TAGCODES = {
    payment_hash: 1,
    payment_secret: 16,
    description: 13,
    payee: 19,
    description_hash: 23,
    expiry: 6,
    min_final_cltv_expiry: 24,
    fallback_address: 9,
    route_hint: 3,
    feature_bits: 5,
    metadata: 27
};
// reverse the keys and values of TAGCODES and insert into TAGNAMES
var TAGNAMES = {};
for (var i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {
    var currentName = keys[i];
    var currentCode = TAGCODES[keys[i]].toString();
    TAGNAMES[currentCode] = currentName;
}
var TAGPARSERS = {
    1: function (words) { return wordsToBuffer(words, true); },
    16: function (words) { return wordsToBuffer(words, true); },
    13: function (words) { return wordsToBuffer(words, true).toString('utf8'); },
    19: function (words) { return wordsToBuffer(words, true); },
    23: function (words) { return wordsToBuffer(words, true); },
    27: function (words) { return wordsToBuffer(words, true); },
    6: wordsToIntBE,
    24: wordsToIntBE,
    3: routingInfoParser,
    5: featureBitsParser // keep feature bits as array of 5 bit words
};
function getUnknownParser(tagCode) {
    return function (words) { return ({
        tagCode: parseInt(tagCode),
        words: bech32.encode('unknown', words, Number.MAX_SAFE_INTEGER)
    }); };
}
function wordsToIntBE(words) {
    return words.reverse().reduce(function (total, item, index) {
        return total + item * Math.pow(32, index);
    }, 0);
}
function convert(data, inBits, outBits) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];
    for (var i = 0; i < data.length; ++i) {
        value = (value << inBits) | data[i];
        bits += inBits;
        while (bits >= outBits) {
            bits -= outBits;
            result.push((value >> bits) & maxV);
        }
    }
    if (bits > 0) {
        result.push((value << (outBits - bits)) & maxV);
    }
    return result;
}
function wordsToBuffer(words, trim) {
    var buffer = buffer_1.Buffer.from(convert(words, 5, 8));
    if (trim && (words.length * 5) % 8 !== 0) {
        buffer = buffer.slice(0, -1);
    }
    return buffer;
}
// first convert from words to buffer, trimming padding where necessary
// parse in 51 byte chunks. See encoder for details.
function routingInfoParser(words) {
    var routes = [];
    var pubkey, shortChannelId, feeBaseMSats, feeProportionalMillionths, cltvExpiryDelta;
    var routesBuffer = wordsToBuffer(words, true);
    while (routesBuffer.length > 0) {
        pubkey = routesBuffer.slice(0, 33).toString('hex'); // 33 bytes
        shortChannelId = routesBuffer.slice(33, 41).toString('hex'); // 8 bytes
        feeBaseMSats = parseInt(routesBuffer.slice(41, 45).toString('hex'), 16); // 4 bytes
        feeProportionalMillionths = parseInt(routesBuffer.slice(45, 49).toString('hex'), 16); // 4 bytes
        cltvExpiryDelta = parseInt(routesBuffer.slice(49, 51).toString('hex'), 16); // 2 bytes
        routesBuffer = routesBuffer.slice(51);
        routes.push({
            pubkey: pubkey,
            short_channel_id: shortChannelId,
            fee_base_msat: feeBaseMSats,
            fee_proportional_millionths: feeProportionalMillionths,
            cltv_expiry_delta: cltvExpiryDelta
        });
    }
    return routes;
}
function featureBitsParser(words) {
    var bools = words
        .slice()
        .reverse()
        .map(function (word) { return [
        !!(word & 1),
        !!(word & 2),
        !!(word & 4),
        !!(word & 8),
        !!(word & 16)
    ]; })
        .reduce(function (finalArr, itemArr) { return finalArr.concat(itemArr); }, []);
    while (bools.length < FEATUREBIT_ORDER.length * 2) {
        bools.push(false);
    }
    var featureBits = { extra_bits: {} };
    FEATUREBIT_ORDER.forEach(function (featureName, index) {
        var status;
        if (bools[index * 2]) {
            status = 'required';
        }
        else if (bools[index * 2 + 1]) {
            status = 'supported';
        }
        featureBits[featureName] = status;
    });
    if (bools.length > FEATUREBIT_ORDER.length * 2) {
        var extraBits = bools.slice(FEATUREBIT_ORDER.length * 2);
        featureBits.extra_bits = {
            start_bit: FEATUREBIT_ORDER.length * 2,
            bits: extraBits,
            required: extraBits.reduce(function (result, bit, index) {
                return index % 2 !== 0 ? result || false : result || bit;
            }, false)
        };
    }
    return featureBits;
}
function hrpToMillisat(hrpString, outputString) {
    var divisor, value;
    if (hrpString.slice(-1).match(/^[munp]$/)) {
        divisor = hrpString.slice(-1);
        value = hrpString.slice(0, -1);
    }
    else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {
        throw new Error('Not a valid multiplier for the amount');
    }
    else {
        value = hrpString;
    }
    if (!value.match(/^\d+$/))
        throw new Error('Not a valid human readable amount');
    var valueBN = new bn_js_1.BN(value, 10);
    var millisatoshisBN = divisor
        ? valueBN.mul(MILLISATS_PER_BTC).div(DIVISORS[divisor])
        : valueBN.mul(MILLISATS_PER_BTC);
    if ((divisor === 'p' && !valueBN.mod(new bn_js_1.BN(10, 10)).eq(new bn_js_1.BN(0, 10))) ||
        millisatoshisBN.gt(MAX_MILLISATS)) {
        throw new Error('Amount is outside of valid range');
    }
    return outputString ? millisatoshisBN.toString() : millisatoshisBN;
}
exports.hrpToMillisat = hrpToMillisat;
// decode will only have extra comments that aren't covered in encode comments.
// also if anything is hard to read I'll comment.
function decode(paymentRequest, network) {
    if (typeof paymentRequest !== 'string')
        throw new Error('Lightning Payment Request must be string');
    if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln')
        throw new Error('Not a proper lightning payment request');
    var sections = [];
    var decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER);
    paymentRequest = paymentRequest.toLowerCase();
    var prefix = decoded.prefix;
    var words = decoded.words;
    var letters = paymentRequest.slice(prefix.length + 1);
    var sigWords = words.slice(-104);
    words = words.slice(0, -104);
    // Without reverse lookups, can't say that the multipier at the end must
    // have a number before it, so instead we parse, and if the second group
    // doesn't have anything, there's a good chance the last letter of the
    // coin type got captured by the third group, so just re-regex without
    // the number.
    var prefixMatches = prefix.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
    if (prefixMatches && !prefixMatches[2])
        prefixMatches = prefix.match(/^ln(\S+)$/);
    if (!prefixMatches) {
        throw new Error('Not a proper lightning payment request');
    }
    // "ln" section
    sections.push({
        name: 'lightning_network',
        letters: 'ln'
    });
    // "bc" section
    var bech32Prefix = prefixMatches[1];
    var coinNetwork;
    if (!network) {
        switch (bech32Prefix) {
            case DEFAULTNETWORK.bech32:
                coinNetwork = DEFAULTNETWORK;
                break;
            case TESTNETWORK.bech32:
                coinNetwork = TESTNETWORK;
                break;
            case REGTESTNETWORK.bech32:
                coinNetwork = REGTESTNETWORK;
                break;
            case SIMNETWORK.bech32:
                coinNetwork = SIMNETWORK;
                break;
        }
    }
    else {
        if (network.bech32 === undefined ||
            network.pubKeyHash === undefined ||
            network.scriptHash === undefined ||
            !Array.isArray(network.validWitnessVersions))
            throw new Error('Invalid network');
        coinNetwork = network;
    }
    if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {
        throw new Error('Unknown coin bech32 prefix');
    }
    sections.push({
        name: 'coin_network',
        letters: bech32Prefix,
        value: coinNetwork
    });
    // amount section
    var value = prefixMatches[2];
    var millisatoshis;
    if (value) {
        var divisor = prefixMatches[3];
        millisatoshis = hrpToMillisat(value + divisor, true);
        sections.push({
            name: 'amount',
            letters: prefixMatches[2] + prefixMatches[3],
            value: millisatoshis
        });
    }
    else {
        millisatoshis = null;
    }
    // "1" separator
    sections.push({
        name: 'separator',
        letters: '1'
    });
    // timestamp
    var timestamp = wordsToIntBE(words.slice(0, 7));
    words = words.slice(7); // trim off the left 7 words
    sections.push({
        name: 'timestamp',
        letters: letters.slice(0, 7),
        value: timestamp
    });
    letters = letters.slice(7);
    var tagName, parser, tagLength, tagWords;
    // we have no tag count to go on, so just keep hacking off words
    // until we have none.
    while (words.length > 0) {
        var tagCode = words[0].toString();
        tagName = TAGNAMES[tagCode] || 'unknown_tag';
        parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode);
        words = words.slice(1);
        tagLength = wordsToIntBE(words.slice(0, 2));
        words = words.slice(2);
        tagWords = words.slice(0, tagLength);
        words = words.slice(tagLength);
        sections.push({
            name: tagName,
            tag: letters[0],
            letters: letters.slice(0, 1 + 2 + tagLength),
            value: parser(tagWords) // see: parsers for more comments
        });
        letters = letters.slice(1 + 2 + tagLength);
    }
    // signature
    sections.push({
        name: 'signature',
        letters: letters.slice(0, 104),
        value: wordsToBuffer(sigWords, true)
    });
    letters = letters.slice(104);
    // checksum
    sections.push({
        name: 'checksum',
        letters: letters
    });
    var result = {
        paymentRequest: paymentRequest,
        sections: sections,
        get expiry() {
            var exp = sections.find(function (s) { return s.name === 'expiry'; });
            if (exp)
                return getValue('timestamp') + exp.value;
        },
        get route_hints() {
            return sections.filter(function (s) { return s.name === 'route_hint'; }).map(function (s) { return s.value; });
        }
    };
    var _loop_1 = function (name_1) {
        if (name_1 === 'route_hint') {
            return "continue";
        }
        Object.defineProperty(result, name_1, {
            get: function () {
                return getValue(name_1);
            }
        });
    };
    for (var name_1 in TAGCODES) {
        _loop_1(name_1);
    }
    return result;
    function getValue(name) {
        var section = sections.find(function (s) { return s.name === name; });
        return section ? section.value : undefined;
    }
}
exports.decode = decode;
